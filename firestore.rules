/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model coupled with role-based
 * access control (RBAC) for administrative actions. Most data is private to the user, but users
 * with an 'admin' role are granted broader permissions to manage the system.
 *
 * Data Structure: All private user data is hierarchically organized under `/users/{userId}`.
 * Global data and administrative collections like `subscriptionPlans`, `roles`, and `userRoles`
 * are stored in top-level collections. A user's role is stored directly on their user document
 * in the `/users/{userId}` path (e.g., `role: 'admin'`).
 *
 * Key Security Decisions:
 * - User Isolation: A user can always access documents within their own `/users/{userId}` path.
 * - Admin Privilege: Users with `role == 'admin'` can read and write to most data for
 *   administrative purposes.
 * - No Public User Listing: To protect user privacy, only admin users can list all documents
 *   in the `/users` collection.
 * - Safe Deletion: Users are not permitted to delete their own user profile document directly.
 *   Account deletion should be handled by a secure backend process.
 *
 * Denormalization for Authorization: The security model relies on denormalizing the `userId` onto
 * documents within user subcollections (e.g., a `template` document contains a `userId` field).
 * This avoids slow and costly `get()` calls to parent documents and allows rules to validate
 * that a document's internal `userId` reference matches the user ID in the path, ensuring data integrity.
 *
 * Role-Based Access Control (RBAC): The `isAdmin()` function centralizes the logic for checking
 * administrative privileges. It performs a single `get()` to the requesting user's own profile
 * document to check their role. This is a secure and reasonably performant way to manage permissions.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for reusable logic
    /**
     * isSignedIn
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * isOwner
     * Checks if the authenticated user's UID matches the provided userId.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * isExistingOwner
     * Checks if a document exists and if the user is the owner.
     * Used for safe updates and deletes.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
    
    /**
     * isAdmin
     * Checks if the requesting user has the 'admin' role by reading their user document.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * @description   Allows admins to perform collection group queries across all 'subscriptions'.
     * @path          /{path=**}/subscriptions/{subscriptionId}
     * @allow         (get, list) An admin user.
     * @principle     Enables platform-wide querying for administrative purposes like the global subscriptions page.
     */
    match /{path=**}/subscriptions/{subscriptionId} {
      allow get, list: if isAdmin();
    }

    /**
     * @description   Stores user profile information.
     * @path          /users/{userId}
     * @allow         (create) An authenticated user creating their own profile document.
     * @allow         (get) An authenticated user reading their own profile, or an admin reading any profile.
     * @allow         (update) An authenticated user updating their own profile, or an admin updating any profile.
     * @allow         (list) An admin user listing all user profiles.
     * @deny          (delete) A user trying to delete their own profile.
     * @principle     Restricts access to a user's own data, but allows admins full read/write access.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if (isOwner(userId) || isAdmin()) && request.resource.data.id == userId;
      allow update: if (isOwner(userId) || isAdmin()) && request.resource.data.id == resource.data.id;
      allow delete: if isAdmin(); // Deletion should be an admin process

      /**
       * @description   Stores a user's subscription history.
       * @path          /users/{userId}/subscriptions/{subscriptionId}
       * @allow         A user managing their own subscriptions, or an admin.
       * @principle     Enforces path-based ownership, with admin override.
       */
      match /subscriptions/{subscriptionId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }

      /**
       * @description   Stores a user's invoices.
       * @path          /users/{userId}/invoices/{invoiceId}
       * @allow         (read) A user reading their own invoices.
       * @allow         (write) Admins can manage invoices (e.g., for manual adjustments). In production, this should be a webhook.
       * @principle     Enforces path-based ownership for reads, admin-only for writes.
       */
      match /invoices/{invoiceId} {
        allow read: if isOwner(userId) || isAdmin();
        allow write: if isAdmin();
      }

      /**
       * @description   Stores a user's custom dashboard layouts.
       * @path          /users/{userId}/dashboardLayouts/{dashboardLayoutId}
       * @allow         A user managing their own layouts, or an admin.
       * @principle     Enforces path-based ownership, with admin override.
       */
      match /dashboardLayouts/{dashboardLayoutId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }

      /**
       * @description   Stores templates generated by a user.
       * @path          /users/{userId}/templates/{templateId}
       * @allow         A user managing their own templates, or an admin.
       * @principle     Enforces path-based ownership, with admin override.
       */
      match /templates/{templateId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }
    }

    /**
     * @description   Publicly readable list of available subscription plans.
     * @path          /subscriptionPlans/{subscriptionPlanId}
     * @allow         (get, list) Any user reading the available plans.
     * @allow         (create, update, delete) Admins can manage plans.
     * @principle     Segregates public read-only data, with write access restricted to admins.
     */
    match /subscriptionPlans/{subscriptionPlanId} {
      allow get: if true;
      allow list: if true;
      allow write: if isAdmin();
    }

    /**
     * @description   Associates users with roles. This collection should only be managed by administrators.
     * @path          /userRoles/{userRoleId}
     * @allow         Admins can manage user role associations.
     * @principle     Secures administrative data by restricting access to admins only.
     */
    match /userRoles/{userRoleId} {
      allow read, write: if isAdmin();
    }

    /**
     * @description   Publicly readable list of system roles (e.g., Admin, Editor).
     * @path          /roles/{roleId}
     * @allow         (get, list) Any authenticated user reading the available system roles.
     * @allow         (create, update, delete) Admins can manage roles.
     * @principle     Allows clients to read system configuration while restricting modification to admins.
     */
    match /roles/{roleId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow write: if isAdmin();
    }

    /**
     * @description   Stores global feature flags.
     * @path          /featureFlags/{flagId}
     * @allow         (read, write) Admins can manage feature flags.
     * @principle     Secures administrative data by restricting access to admins only.
     */
    match /featureFlags/{flagId} {
      allow read, write: if isAdmin();
    }
    
    /**
     * @description   Stores global platform settings.
     * @path          /platform/{docId}
     * @allow         (read, write) Admins can manage platform settings.
     * @principle     Secures administrative data by restricting access to admins only.
     */
    match /platform/{docId} {
      allow read, write: if isAdmin();
    }

    /**
     * @description   Stores audit logs of important actions. Only readable and writable by admins.
     * @path          /auditLogs/{logId}
     * @allow         Admins can read and write audit logs.
     * @principle     Secures sensitive audit trail data.
     */
    match /auditLogs/{logId} {
      allow read, write: if isAdmin();
    }
  }
}
